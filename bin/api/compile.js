// Generated by CoffeeScript 1.7.1
(function() {
  var coffeescript, fs, jade, less, livescript, sass, stylus, _;

  fs = require('fs');

  _ = require('lodash');

  _.mixin(require('underscore.string').exports());

  coffeescript = require('coffee-script');

  livescript = require('LiveScript');

  sass = require('node-sass');

  stylus = require('stylus');

  less = require('less');

  jade = require('jade');


  /*
     @param input {object}: 
        file {string}: input file path (will be used to select the appropriate compiler).
        code [string]: raw code (compiles the code without reading file from file sytem).
        source_map [object]: if defined compilation will try to generate a Mozilla V3 source map (not available for all compilers).
           file [string]: output file path (absolute or relative to source map file).
           sourceRoot [string]: root path prepended to source paths.
           sources {array}: an array of source paths involved in mapping. 
        options [object]: additional compiler configurations. 
     @param back {function}: asynchronous callback function.
     @return output {object}:
        code {string}: compiled string code.
        source_map {object}: source map if required, null otherwise.
        warnings {array}: compilation warnings.
   */

  exports['coffeescript'] = function(input, back) {
    var compiled, err, options, output;
    if (!_.isFunction(back)) {
      throw new Error('callback is required {function}.');
    }
    if (!_.isObject(input)) {
      return back(new Error('input is required {object}.'));
    }
    if (!_.isString(input.file)) {
      return back(new Error('input.file is required {string}.'));
    }
    if (_.isObject(input.source_map && !_.isArray(input.source_map.sources))) {
      return back(new Error('input.source_map.sources is required {array}.'));
    }
    try {
      if (_.isEmpty(input.code)) {
        input.code = fs.readFileSync(input.file, 'utf8');
      }
      output = {};
      output.code = null;
      output.source_map = null;
      output.warnings = [];
      options = {};
      options.filename = input.file;
      options = _.merge(options, input.options || {});
      if (_.isObject(input.source_map)) {
        options.sourceMap = true;
        options.sourceRoot = input.source_map.sourceRoot || '';
        options.sourceFiles = input.source_map.sources || [];
        options.generatedFile = input.source_map.file || '';
      }
      compiled = coffeescript.compile(input.code, options);
      output.code = compiled.js || compiled;
      if (compiled.v3SourceMap) {
        output.source_map = JSON.parse(compiled.v3SourceMap);
      }
      output.warnings = [];
      return back(null, output);
    } catch (_error) {
      err = _error;
      return back(err);
    }
  };

  exports['livescript'] = function(input, back) {
    var compiled, err, output;
    if (!_.isFunction(back)) {
      throw new Error('callback is required {function}.');
    }
    if (!_.isObject(input)) {
      return back(new Error('input is required {object}.'));
    }
    if (!_.isString(input.file)) {
      return back(new Error('input.file is required {string}.'));
    }
    if (_.isObject(input.source_map && !_.isArray(input.source_map.sources))) {
      return back(new Error('input.source_map.sources is required {array}.'));
    }
    try {
      if (_.isEmpty(input.code)) {
        input.code = fs.readFileSync(input.file, 'utf8');
      }
      output = {};
      output.code = null;
      output.source_map = null;
      output.warnings = [];
      compiled = livescript.compile(input.code);
      output.code = compiled;
      if (_.isObject(input.source_map)) {
        output.warnings.push('livescript doesn\'t support source maps.');
      }
      return back(null, output);
    } catch (_error) {
      err = _error;
      return back(err);
    }
  };

  exports['sass'] = function(input, back) {
    var err, options, output;
    if (!_.isFunction(back)) {
      throw new Error('callback is required {function}.');
    }
    if (!_.isObject(input)) {
      return back(new Error('input is required {object}.'));
    }
    if (!_.isString(input.file)) {
      return back(new Error('input.file is required {string}.'));
    }
    if (_.isObject(input.source_map && !_.isArray(input.source_map.sources))) {
      return back(new Error('input.source_map.sources is required {array}.'));
    }
    try {
      if (_.isEmpty(input.code)) {
        input.code = fs.readFileSync(input.file, 'utf8');
      }
      output = {};
      output.code = null;
      output.source_map = null;
      output.warnings = [];
      options = {};
      options.file = input.file;
      options.data = input.code;
      options = _.merge(options, input.options || {});
      if (_.isObject(input.source_map)) {
        options.sourceComments = 'map';
        options.sourceMap = '.';
        options.outFile = '.';
      }
      options.error = function(err) {
        return back(new Error(err.replace(options.file + ':', '').replace('\n', '')));
      };
      options.success = function(compiled, map) {
        var err, mappings;
        try {
          output.code = compiled;
          if (_.isObject(input.source_map)) {
            mappings = _.strRight(map, '"mappings":');
            mappings = _.trim(mappings).replace(/\}/g, '').replace(/\n/g, '').replace(/"/g, '');
            output.source_map = {
              version: 3,
              file: input.source_map.file || '',
              sourceRoot: input.source_map.sourceRoot || '',
              sources: input.source_map.sources || [],
              names: [],
              mappings: mappings
            };
          }
          return back(null, output);
        } catch (_error) {
          err = _error;
          return back(err);
        }
      };
      return sass.render(options);
    } catch (_error) {
      err = _error;
      return back(err);
    }
  };

  exports['less'] = function(input, back) {
    var err, options, output;
    if (!_.isFunction(back)) {
      throw new Error('callback is required {function}.');
    }
    if (!_.isObject(input)) {
      return back(new Error('input is required {object}.'));
    }
    if (!_.isString(input.file)) {
      return back(new Error('input.file is required {string}.'));
    }
    if (_.isObject(input.source_map && !_.isArray(input.source_map.sources))) {
      return back(new Error('input.source_map.sources is required {array}.'));
    }
    try {
      if (_.isEmpty(input.code)) {
        input.code = fs.readFileSync(input.file, 'utf8');
      }
      output = {};
      output.code = null;
      output.source_map = null;
      output.warnings = [];
      options = {};
      options = _.merge(options, input.options || {});
      if (_.isObject(input.source_map)) {
        options.sourceMap = true;
        options.writeSourceMap = function(map) {
          output.source_map = JSON.parse(map);
          output.source_map.sourceRoot = input.source_map.sourceRoot || '';
          output.source_map.sources = input.source_map.sources || [];
          return output.source_map.file = input.source_map.file || '';
        };
      }
      return less.render(input.code, options, function(err, compiled) {
        if (err) {
          return back(err);
        }
        output.code = compiled;
        return back(null, output);
      });
    } catch (_error) {
      err = _error;
      return back(err);
    }
  };

  exports['stylus'] = function(input, back) {
    var err, output;
    if (!_.isFunction(back)) {
      throw new Error('callback is required {function}.');
    }
    if (!_.isObject(input)) {
      return back(new Error('input is required {object}.'));
    }
    if (!_.isString(input.file)) {
      return back(new Error('input.file is required {string}.'));
    }
    if (_.isObject(input.source_map && !_.isArray(input.source_map.sources))) {
      return back(new Error('input.source_map.sources is required {array}.'));
    }
    try {
      if (_.isEmpty(input.code)) {
        input.code = fs.readFileSync(input.file, 'utf8');
      }
      output = {};
      output.code = null;
      output.source_map = null;
      output.warnings = [];
      stylus = stylus(input.code);
      stylus.set('filename', input.file);
      stylus.set('options', input.options || {});
      stylus.set('sourcemap', {
        comment: false
      });
      return stylus.render(function(err, compiled) {
        if (err) {
          return back(err);
        }
        output.code = compiled;
        output.source_map = stylus.sourcemap;
        output.source_map.file = input.source_map.file || '';
        output.source_map.sourceRoot = input.source_map.sourceRoot || '';
        output.source_map.sources = input.source_map.sources || [];
        return back(null, output);
      });
    } catch (_error) {
      err = _error;
      return back(err);
    }
  };

  exports['jade'] = function(input, back) {
    var err, output;
    if (!_.isFunction(back)) {
      throw new Error('callback is required {function}.');
    }
    if (!_.isObject(input)) {
      return back(new Error('input is required {object}.'));
    }
    if (!_.isString(input.file)) {
      return back(new Error('input.file is required {string}.'));
    }
    if (_.isObject(input.source_map && !_.isArray(input.source_map.sources))) {
      return back(new Error('input.source_map.sources is required {array}.'));
    }
    try {
      if (_.isEmpty(input.code)) {
        input.code = fs.readFileSync(input.file, 'utf8');
      }
      output = {};
      output.code = null;
      output.source_map = null;
      output.warnings = [];
      return jade.render(input.code, input.options || {}, function(err, compiled) {
        if (err) {
          return back(err);
        }
        output.code = compiled;
        return back(null, output);
      });
    } catch (_error) {
      err = _error;
      return back(err);
    }
  };

  exports['coffee'] = this['coffeescript'];

  exports['litcoffee'] = this['coffeescript'];

  exports['ls'] = this['livescript'];

  exports['less'] = this['less'];

  exports['sass'] = this['sass'];

  exports['scss'] = this['sass'];

  exports['styl'] = this['stylus'];

  exports['stylus'] = this['stylus'];

  exports['jade'] = this['jade'];

}).call(this);

//# sourceMappingURL=compile.map
