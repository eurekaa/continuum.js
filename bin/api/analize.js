// Generated by CoffeeScript 1.7.1
(function() {
  var csslint, fs, htmlint, jshint, source_map, _;

  fs = require('fs');

  _ = require('lodash');

  _.mixin(require('underscore.string').exports());

  jshint = require('jshint').JSHINT;

  csslint = require('csslint').CSSLint;

  htmlint = require('html5-lint');

  source_map = require('./source_map.js');

  exports['javascript'] = function(input, back) {
    var err, item, position, result, warning, warnings, _i, _len, _ref;
    if (!_.isFunction(back)) {
      throw new Error('callback is required {function}.');
    }
    if (!_.isObject(input)) {
      return back(new Error('input is required {object}.'));
    }
    if (!_.isString(input.file)) {
      return back(new Error('input.file is required {string}.'));
    }
    try {
      warnings = [];
      if (!input.code) {
        input.code = fs.readFileSync(input.file, 'utf-8');
      }
      result = jshint(input.code, input.options);
      if (result === false) {
        _ref = jshint.errors;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          item = _ref[_i];
          if (!(item !== null)) {
            continue;
          }
          warning = {};
          warning.message = _.trim(item.reason);
          warning.code = _.trim(item.evidence);
          warning.source_mapped = false;
          warning.line = item.line;
          warning.column = item.character;
          if (_.isObject(input.source_map) && _.has(input.source_map, 'mappings') && _.isString(input.source)) {
            position = source_map.get_original_position(input.source_map, {
              source: input.source_map.sources[0],
              line: warning.line,
              column: warning.column
            });
            warning.source_mapped = position.line !== null;
            if (warning.source_mapped === true) {
              warning.line = position.line;
              warning.column = position.column;
              warning.code = _.trim(_.lines(input.source)[position.line - 1]);
            }
          }
          warnings.push(warning);
        }
      }
      return back(null, warnings);
    } catch (_error) {
      err = _error;
      return back(err);
    }
  };

  exports['stylesheet'] = function(input, back) {
    var err, item, position, result, warning, warnings, _i, _len, _ref;
    if (!_.isFunction(back)) {
      throw new Error('callback is required {function}.');
    }
    if (!_.isObject(input)) {
      return back(new Error('input is required {object}.'));
    }
    if (!_.isString(input.file)) {
      return back(new Error('input.file is required {string}.'));
    }
    try {
      warnings = [];
      if (!input.code) {
        input.code = fs.readFileSync(input.file, 'utf-8');
      }
      result = csslint.verify(input.code, input.options);
      _ref = result.messages;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        item = _ref[_i];
        if (!(item !== null)) {
          continue;
        }
        warning = {};
        warning.message = _.trim(_.strLeft(item.message, 'at line'));
        warning.code = _.trim(item.evidence);
        warning.source_mapped = false;
        warning.line = item.line;
        warning.column = item.col;
        if (_.isObject(input.source_map) && _.has(input.source_map, 'mappings') && _.isString(input.source)) {
          position = source_map.get_original_position(input.source_map, {
            source: input.source_map.sources[0],
            line: warning.line,
            column: warning.column
          });
          warning.source_mapped = position.line !== null;
          if (warning.source_mapped === true) {
            warning.line = position.line;
            warning.column = position.column;
            warning.code = _.trim(_.lines(input.source)[position.line - 1]);
          }
        }
        warnings.push(warning);
      }
      return back(null, warnings);
    } catch (_error) {
      err = _error;
      return back(err);
    }
  };

  exports['hypertext'] = function(input, back) {
    var err, warnings;
    if (!_.isFunction(back)) {
      throw new Error('callback is required {function}.');
    }
    if (!_.isObject(input)) {
      return back(new Error('input is required {object}.'));
    }
    if (!_.isString(input.file)) {
      return back(new Error('input.file is required {string}.'));
    }
    try {
      warnings = [];
      if (!input.code) {
        input.code = fs.readFileSync(input.file, 'utf-8');
      }
      return htmlint(input.code, input.options, function(err, result) {
        var item, position, warning, _i, _len, _ref;
        if (err && err.message === 'Bad Gateway') {
          return back(new Error('Web service for html5 analysis in not reachable.'));
        }
        if (err) {
          return back(err);
        }
        _ref = result.messages;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          item = _ref[_i];
          if (!(item !== null)) {
            continue;
          }
          warning = {};
          warning.message = _.trim(item.message);
          warning.code = _.trim(item.extract + '..');
          warning.source_mapped = false;
          warning.line = item.lastLine;
          warning.column = item.lastColumn;
          if (_.isObject(input.source_map) && _.has(input.source_map, 'mappings') && _.isString(input.source)) {
            position = source_map.get_original_position(input.source_map, {
              source: input.source_map.sources[0],
              line: warning.line,
              column: warning.column
            });
            warning.source_mapped = position.line !== null;
            if (warning.source_mapped === true) {
              warning.line = position.line;
              warning.column = position.column;
              warning.code = _.trim(_.lines(input.source)[position.line - 1]);
            }
          }
          warnings.push(warning);
        }
        return back(null, warnings);
      });
    } catch (_error) {
      err = _error;
      return back(err);
    }
  };

  exports['js'] = this['javascript'];

  exports['css'] = this['stylesheet'];

  exports['html'] = this['hypertext'];

  exports['htm'] = this['hypertext'];

}).call(this);

//# sourceMappingURL=analize.map
